package pdh.papervision{	import pdh.papervision.RenderManager;	import pdh.bitmap.Blur;	import pdh.math.Angle;	import pdh.bitmap.MirrorImage;	import pdh.events.Wall3dEvent;		import gs.TweenMax;	import gs.easing.*;		import flash.display.BlendMode;	import flash.display.StageQuality;	import flash.filters.GlowFilter;		import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.text.TextField;	import flash.utils.Dictionary;				import flash.events.*;	import flash.events.Event;		import flash.events.TimerEvent;	import flash.utils.Timer;	import pdh.graphics.Box;		// required papervision classes	import org.papervision3d.render.BasicRenderEngine;	import org.papervision3d.view.Viewport3D;	import org.papervision3d.scenes.Scene3D;	import org.papervision3d.cameras.Camera3D;		// material and textures	import org.papervision3d.materials.BitmapFileMaterial;	//import org.papervision3d.materials.MovieMaterial;	import org.papervision3d.materials.BitmapMaterial;	import org.papervision3d.materials.MovieAssetMaterial;	//import org.papervision3d.materials.BitmapAssetMaterial;	//import org.papervision3d.materials.BitmapColorMaterial;	import org.papervision3d.events.InteractiveScene3DEvent;		//import 	org.papervision3d.objects.primitives.Cylinder;		import org.papervision3d.events.FileLoadEvent;		// objects	import org.papervision3d.objects.DisplayObject3D;	import org.papervision3d.objects.primitives.Plane;		import pdh.papervision.Basic3dSprite;		public class Wall3d extends Basic3dSprite	{		// these should be able to have their values set		protected const dragSpeed			:uint = 2;		protected const maxXRange			:uint = 60;			protected const WALL_Y				:int = -100;  		protected const IMAGE_WIDTH			:uint = 178;		protected const IMAGE_HEIGHT		:uint = 100;		protected const MAXSPEED			:uint = 6;		protected const ROLLOVER_GLOW		:Number = 0x39acff;								protected var photoWall				:DisplayObject3D;			protected var lastRolloverTarget	:DisplayObject3D;				protected var planeDict			:Dictionary			protected var mouseArea			:Box;		protected var h					:Number;		protected var w					:Number;		protected var startMouseY			:Number;		protected var lastCamX			:Number;		protected var startMouseX			:Number;		protected var lastWallY			:Number;		protected var photosPerLevel		:int;		protected var angleJump 			:Number		protected var wall3dRadius		:Number;		protected var camZpos				:Number;		protected var rotatespeed			:Number = 0; 		protected var currentView			:int = 1;		protected var anglePer			:Number		protected var numOfRotations		:uint					protected var _wallAnimating		:Boolean = false;		protected var mouseDragging		:Boolean = false;		protected var mouseLookEnabled	:Boolean = false;		protected var rotationStarted		:Boolean = false;						public var useMirror			:Boolean = true;				function Wall3d(_w:Number, _h:Number):void 		{			mouseArea = new Box(_w, _h, 0x000000);			mouseArea.width = _w;			mouseArea.height = _h;			mouseArea.alpha = 0;						addChild(mouseArea);						addEventListener(MouseEvent.MOUSE_WHEEL, onMouseWheelEvent, true,0, true);			mouseArea.addEventListener(MouseEvent.MOUSE_DOWN, mouseAreaClick, false,0, true);			mouseArea.addEventListener(MouseEvent.MOUSE_UP, mouseAreaClick, false,0, true);						setupScene(_w, _h)						view.visible = true;			view.containerSprite.buttonMode = true; // shows hand cursor						// create photo wall			photoWall = new DisplayObject3D();			scene.addChild(photoWall)			photoWall.visible = true;		}				//------------------------------------------------------------------------------------------------------------ INPUT / OUTPUT				public function getPhotoWall():DisplayObject3D 		{			return photoWall;		}						public function initCamWall():void 		{			camera.x = 0;			camera.z = 0;			camera.y = 0;			camera.zoom = 50;				photoWall.y = 0;							}				public function get3dObjectByIndex(_index:String):DisplayObject3D		{			var threedobj:DisplayObject3D = null;			for (var key:* in planeDict) {			   			   if (planeDict[key].index == _index){ 						   		threedobj = key;			   		break;			   }			}			return threedobj;		}						//------------------------------------------------------------------------------------------------------------ MISC								public function showView():void 		{			view.visible = true		}								public function setSize(_w:int, _h:int):void 		{			h = _h;			w = _w;						mouseArea.height = _h;			mouseArea.width = _w;						renderManager.render();					}										// auto rotates the wall		public function setRotate(_speed):void 		{				_speed = (_speed / 100) * MAXSPEED;						rotatespeed = _speed;							if (rotatespeed != 0){					autoRotateStart()								} else {				autoRotateStop();			}		}				protected function autoRotateStart():void 		{			if (rotationStarted) return;			rotationStarted = true;			wallAnimating = true;			this.addEventListener(Event.ENTER_FRAME, handleAutoRotation,false,0,true)					}				protected function autoRotateStop():void 		{			if (!rotationStarted) return;			rotationStarted = false;			wallAnimating = false;			this.removeEventListener(Event.ENTER_FRAME, handleAutoRotation)					}								public function get zoomedIn():Boolean		{			if (currentView == 0){				return true;			} else {				return false;			}		}						protected function movementDone():void 		{			wallAnimating = false;			mouseArea.visible = true;		}				public function activateWall():void 		{			view.mouseEnabled = true			view.mouseChildren = true;			view.interactive = true;		}				public function deactivateWall():void 		{			view.mouseEnabled = false;			view.mouseChildren = false;			view.interactive = false;			dispatchEvent(new Wall3dEvent(Wall3dEvent.IMAGE_ROLLOUT));			unGlow(lastRolloverTarget);		}											//------------------------------------------------------------------------------------------------------------ mouse				public function set mouseLook(val:Boolean):void 		{			mouseLookEnabled = val;		}				public function get mouseLook():Boolean		{			return mouseLookEnabled;		}								//------------------------------------------------------------------------------------------------------------ 3d objects											// create a wall of 3d images		public function create_thumbnails(walldata:Array):void 		{						planeDict = new Dictionary(true);			var planeArray = new Array();			var total:int = walldata.length;						numOfRotations = 3			photosPerLevel = Math.ceil(total / numOfRotations);					anglePer = (Math.PI*2) / photosPerLevel;				wall3dRadius = ((photosPerLevel * (IMAGE_WIDTH + 10)) / Math.PI) / 2;						// create planes with photos as textures			for(var i:uint = 0; i < total; i++ )			{				// main container for photo, will contain front and back image				var planeHolder:DisplayObject3D = new DisplayObject3D();									// create textured plane				var sourceImage:String = walldata[i].thumbnail;								var bam:BitmapFileMaterial = new BitmapFileMaterial(sourceImage);				bam.addEventListener(FileLoadEvent.LOAD_COMPLETE,onTextureLoaded, false,0, true);				bam.oneSide = false;					bam.smooth = true;				var p:Plane = new Plane(bam, IMAGE_WIDTH, IMAGE_HEIGHT, 2, 2);				planeHolder.addChild(p);								// attach events to the textured plane				p.addEventListener(InteractiveScene3DEvent.OBJECT_RELEASE, p_click, false,0, true);				p.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, p_rollover, false,0, true);				p.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, p_rollout, false,0, true);												// rollover and data association - mapped to plane with photo texture				planeDict[p] = {								data:walldata[i], 								material: bam,								holder:planeHolder,								index:walldata[i].index, 								glow: new GlowFilter(ROLLOVER_GLOW, 1, 12, 12, 2)								}												// create backing for photo plane				/*var backingMaterial:MovieAssetMaterial = new MovieAssetMaterial('photobacking');				backingMaterial.addEventListener(FileLoadEvent.LOAD_COMPLETE,onTextureLoaded, false,0, true);				//backingMaterial.oneSide = false;					backingMaterial.smooth = true;				var backing:Plane = new Plane(backingMaterial, IMAGE_WIDTH, IMAGE_HEIGHT, 2, 2);				backing.rotationY = 180;				planeHolder.addChild(backing);*/												photoWall.addChild(planeHolder);					planeArray.push(p); // array contains the textured planes - not the holder			}											// animate planes into position			movePhotos(planeArray, false)					} // end function				protected function addMirror(targ:DisplayObject3D, material):DisplayObject3D		{			//var targ:DisplayObject3D = holder;						if (material.bitmap == null) return null; // if no texture, dont process						// get bitmap data			var bitmap:BitmapData = material.bitmap;			var finalBitmap:BitmapData = MirrorImage.create(bitmap, 0x000000);						// create 3d plane with new bitmap			var bm:BitmapMaterial = new BitmapMaterial(finalBitmap);				bm.doubleSided = false;			bm.interactive = false;					//bm.mouseEnabled = false;			//bm.useHandCursor = false;			var p:Plane = new Plane(bm, IMAGE_WIDTH, IMAGE_HEIGHT, 1, 1);							/*p.x =  targ.x;			p.z = targ.z;			p.y = -(IMAGE_HEIGHT + 10);			p.rotationY  = targ.rotationY;	*/						//p.x =  planeDict[targ].init.x;			//p.z = planeDict[targ].init.z;			p.y = -(IMAGE_HEIGHT + 10);			//p.rotationY  = planeDict[targ].init.rotationY;							//photoWall.addChild(p);			planeDict[targ].holder.addChild(p)						return p;		}				//------------------------------------------------------------------------------------------------------------ANIMATION SCRIPTS												// move photos to a circle position forming the 3d wall		protected function movePhotos(arr:Array, fromLoc:Boolean, _interactive:Boolean = true):void 		{			removeMirrors();						var _radius:Number = wall3dRadius			var total:int = arr.length;						var vertCounter:int = 1;			var yPos:Number = 0;			var spacing:int = 10;						photosPerLevel = Math.ceil(total / numOfRotations);				angleJump = anglePer * (180/Math.PI);						photoWall.rotationY = (photosPerLevel/2) * angleJump - (90 + angleJump/2);						var extrapos_amount:Number						if (total < 7){				extrapos_amount = 550			}			else if (total < 17){				extrapos_amount = 300			}			else {				extrapos_amount = 40			}						// the position of the camera so it sits back inside the walll			camZpos = -(_radius) + extrapos_amount			var horzCounter:int = 0;						for(var i:uint = 0; i < total; i++ )			{				var _i:int = horzCounter;								var px:Number =  Math.cos(_i*anglePer) * _radius				var py:Number = yPos 				var pz:Number = Math.sin(_i*anglePer) * _radius				var protY:Number = (-_i*anglePer) * (180/Math.PI) + 90								var planeHolderObject:DisplayObject3D = planeDict[arr[i]].holder;								arr[i].material.interactive = _interactive;					arr[i].useOwnContainer = false;	 				planeHolderObject.rotationY = protY;								// if dont move from current location, move from far out instead				if (!fromLoc){					planeHolderObject.z =Math.sin(_i*anglePer) * 2000					planeHolderObject.x = Math.cos(_i*anglePer) * 2000					planeHolderObject.y = py					planeHolderObject.rotationX = 180;				}								TweenMax.to(planeHolderObject, (Math.random() * .5) + .5, {								   x: px, 								   z: pz, 								   y:  py,								   rotationX:0,								   onUpdate:render,								    overwrite:1,								   onComplete:checkAndAddMirror,								   onCompleteParams:[planeDict[arr[i]].material,  arr[i]]								   })									// set position object				var initObj:Object = {x:px, 							y:py, 														z:pz, 							rotationY:protY							}				planeDict[arr[i]].init = initObj;												if( vertCounter >= photosPerLevel ){					yPos += IMAGE_HEIGHT + 10;					horzCounter = 0					vertCounter = 1;				} else {					vertCounter++					horzCounter++;				}					}		}																	//------------------------------------------------------------------------------------------------------------HANDLERS								protected function set wallAnimating(val:Boolean):void 		{			if (val == _wallAnimating) return;						if (val){				//stage.quality = StageQuality.LOW;			} else {				//stage.quality = StageQuality.HIGH;			}			_wallAnimating = val;		}				protected function get wallAnimating():Boolean		{			return _wallAnimating		}										protected function onTextureLoaded(e:FileLoadEvent):void 		{			// find display object by comparing materials			for (var key:* in planeDict) {					   if (planeDict[key].material == e.target){					checkAndAddMirror(e.target, key)					break;			   }			}			render();		}				protected function checkAndAddMirror(_mat, _key:DisplayObject3D):void 		{						if (useMirror){								// check to see if photo is on the bottom				if (planeDict[_key].holder.y == 0){										// should be null before adding					if (planeDict[_key].mirror != null){					   removeMirror(_key)					}										planeDict[_key].mirror = addMirror(_key, _mat);					renderManager.render();				}			}								}				protected function removeMirrors():void 		{			for (var key:* in planeDict) {					  // remove old			   if (planeDict[key].mirror != null){				   removeMirror(key)			   }			}		}				protected function removeMirror(_key):void 		{			planeDict[_key].holder.removeChild(planeDict[_key].mirror);		    planeDict[_key].mirror = null;		}				protected function p_rollover(evt:InteractiveScene3DEvent) 		{									if (currentView != 1) return; // only roll over at view 1									trace("[wall 3d component] rollover " + evt.currentTarget + " | " + evt.target)			if (!wallAnimating && !mouseDragging){								// allows clicking behind 				if (mouseLookEnabled){					mouseArea.visible = false;				}								renderManager.render();				var target3d:DisplayObject3D = evt.target as DisplayObject3D;				target3d.useOwnContainer = true;										var glowFilter:GlowFilter = planeDict[target3d].glow;				glowFilter.blurX = 32;				glowFilter.blurY = 32;				glowFilter.alpha = 0;				target3d.filters = [glowFilter];				TweenMax.to(glowFilter, .2, {alpha:.5, blurX:12, blurY:12,  overwrite:1 ,						   onUpdate:function(){ 						   		renderManager.render();						  		target3d.filters = [glowFilter]						   }						   });												target3d.calculateScreenCoords(camera);								lastRolloverTarget = target3d								dispatchEvent(new Wall3dEvent(Wall3dEvent.IMAGE_ROLLOVER, {											   data:planeDict[target3d].data, 											   x:target3d.screen.x + (w/2), 											   y:target3d.screen.y + (h/2)											   } ));							}		}				protected function p_rollout(evt:InteractiveScene3DEvent) 		{									//if (currentView > 1) return;						if (!wallAnimating){								// allows clicking behind 				if (mouseLookEnabled){					mouseArea.visible = true;				}								trace("rollout")				var target3d:DisplayObject3D = evt.target as DisplayObject3D;								unGlow(target3d);								dispatchEvent(new Wall3dEvent(Wall3dEvent.IMAGE_ROLLOUT));			}			renderManager.render();		}				protected function unGlow(target3d):void 		{						if (target3d == null) return						var glowFilter:GlowFilter = planeDict[target3d].glow;				TweenMax.to(glowFilter, .2, {alpha:0,  overwrite:1 ,						   onUpdate:function(){ 						   		renderManager.render();								target3d.filters = [glowFilter]						   },						   onComplete:function(){								target3d.filters = null								target3d.useOwnContainer = false;	   						   }						   });		}						protected function p_click(evt:InteractiveScene3DEvent) 		{						var target3d:DisplayObject3D = evt.target as DisplayObject3D;			trace(this + "click " + target3d);			dispatchEvent(new Wall3dEvent(Wall3dEvent.IMAGE_CLICK, {target:target3d, data:planeDict[target3d].data} ));		}									protected function handleAutoRotation(e:Event):void 		{			//trace("rotate")			photoWall.rotationY = photoWall.rotationY - rotatespeed;			renderManager.render(); 		}								//------------------------------------------------------------------------------------------------------------  MOUSE										protected function onMouseWheelEvent(e:MouseEvent):void 		{						e.stopImmediatePropagation();									if (!mouseLookEnabled){				trace("[Wall3dComponent]  Mouse look disabled")				return;			}									trace(e.delta); 						var _zoom:Number = camera.zoom + (e.delta * 10);			if (_zoom < 30){				_zoom = 30;			} else if (_zoom > 300){				_zoom = 300;			}									TweenMax.to(camera, .5, {zoom:_zoom,onUpdate:render,  overwrite:1  });		}						protected function mouseAreaClick(e:MouseEvent):void 		{						if (!mouseLookEnabled){				trace("[Wall3dComponent]  Mouse look disabled")				return;			}						switch (e.type){				case MouseEvent.MOUSE_DOWN:										stage.addEventListener( MouseEvent.MOUSE_UP, handleMouseLeave, false, 0, true );					stage.addEventListener( Event.MOUSE_LEAVE, handleMouseLeave, false, 0, true );									startMouseY = e.localY					startMouseX = e.localX										startMouseDrag();					break;				case MouseEvent.MOUSE_UP:																					stopMouseDrag()					break;			}		}				protected function startMouseDrag():void		{			deactivateWall()			mouseDragging = true;			wallAnimating = true;			lastCamX = camera.rotationX;			lastWallY = photoWall.rotationY;								mouseArea.addEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler, false,0, true);			}						protected function stopMouseDrag():void 		{			activateWall()			wallAnimating = false;			mouseDragging = false;			mouseArea.removeEventListener(MouseEvent.MOUSE_MOVE, mouseMoveHandler);		}						protected function handleMouseLeave(e:Event):void 		{			trace("mouse leave!!!!!!");			stage.removeEventListener( MouseEvent.MOUSE_UP, handleMouseLeave);			stage.removeEventListener( Event.MOUSE_LEAVE, handleMouseLeave);			stopMouseDrag();		}								protected function handleMouseOut(e:Event):void 		{			trace("mouse OUT!!!!!!" + e.target + " | " + e.currentTarget);			unGlow(lastRolloverTarget);		}		protected function handleMouseOver(e:Event):void 		{			trace("mouse OVER!!!!!!" + e.target + " | " + e.currentTarget);		}								protected function mouseMoveHandler(e:MouseEvent):void 		{						var n_rotX:Number;						// rotate wall left to right			var targetrotY:Number = ((e.localX - startMouseX) / dragSpeed + lastWallY);									// tilt camera up and down			var targetrotX:Number = ((startMouseY - e.localY) / dragSpeed  + lastCamX);									if (targetrotX > maxXRange){				n_rotX = maxXRange;			} else if (targetrotX < -maxXRange){				n_rotX = -maxXRange;			} else{				n_rotX = targetrotX;			}									var n_Y:Number = -(n_rotX * 10) + WALL_Y;									TweenMax.to(photoWall, .5, {y:n_Y, rotationY:targetrotY, onUpdate:render,  overwrite:1   });			TweenMax.to(camera, .5, {rotationX:n_rotX,  overwrite:1 });		}												// ---------------------------------------------------------------------------------------------------------------- helper funcs						protected function traceValues(obj){			trace("tracing : x=" + obj.x + " y=" + obj.y + " z=" + obj.z+ " roty=" + obj.rotationY+ " rotx=" +obj.rotationX + " rotz=" + obj.rotationZ)		}						protected function spreadAroundPoint(obj:DisplayObject3D, rad2:Number, _inc:int, total:int):void		{						var _angleper = (Math.PI*2) / total // total is the number of things to evenly space out						var _px:Number =  Math.cos(_inc*_angleper) * rad2			var _pz:Number = Math.sin(_inc*_angleper) * rad2			var _protY:Number = (-_inc*_angleper) * (180/Math.PI) + 180									obj.x = _px;  			obj.z = _pz; 			obj.rotationY = _protY;  					}					} // end class		}