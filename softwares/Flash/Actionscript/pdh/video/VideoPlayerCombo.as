/**	requires FLVPlayback component		controls and video window managed in one class*/package pdh.video{	import gs.TweenMax;	import gs.easing.*;	import fl.video.*;	import flash.net.SharedObject;	import pdh.video.FLVPlaybackDispose;	import pdh.ui.UIObject;	import pdh.events.VideoPlayerEvent;	import pdh.video.VideoControls;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.MouseEvent;	import gs.TweenLite;	import gs.easing.*;	import flash.text.TextField;	import pdh.graphics.Box;	import flash.external.ExternalInterface;	import pdh.util.PhotoViewer;	import pdh.events.VideoControlsEvent;	import pdh.text.TextHelper;	import flash.media.SoundTransform;		public class VideoPlayerCombo extends UIObject	{				private static var browserURL	:String ="";		public static const SEEKING		:String = VideoState.SEEKING;		public static const PAUSED		:String = VideoState.PAUSED;				private var videoPlayer			:FLVPlaybackDispose = new FLVPlaybackDispose(); 		private var staticImage			:PhotoViewer;				// stage instances		public var videoControls		:VideoControls;		public var video_holder			:MovieClip;		public var videoPlayerCaption	:*;		public var bufferingBar			:Sprite;		public var paused_mc			:MovieClip		public var playOnLoad			:Boolean = true; // can cancel out autoplay, if false will only load video		private var autoplay			:Boolean = true;		private var videoControlY		:Number = 0;		private var lastVideoFLV		:String;		private var mouseIsOver			:Boolean = false;		private var box					:Box;		private var showCaptions		:Boolean = false;				private var pre_seek_playing	:Boolean = false;				private var cuePointArray		:Array;				function VideoPlayerCombo()		{			init();			addListeners();		}				private function init():void 		{								if (browserURL == ""){				if (ExternalInterface.available)					browserURL = ExternalInterface.call('window.location.href.toString');			}								if (videoControls.caption_button != null){				// get caption state from shared object				var so:SharedObject = SharedObject.getLocal("vplayer_caption");				if (so.data.captionEnabled != undefined){					showCaptions = so.data.captionEnabled;					if (showCaptions) videoControls.captionToggle() 				}			}						if (ExternalInterface.available){				// figure out abolute path to html page (stupid relative path problem with flv)				var urlSplit:Array = browserURL.split("#")				var lastSlash:int = urlSplit[0].lastIndexOf("/")				browserURL = urlSplit[0].slice(0, lastSlash+1)			} else {				browserURL = ""			}								trace("[VideoPlayer] creating videoPlayer")			//videoPlayer = new FLVPlayback();//Dispose();			videoPlayer.skin = null			videoPlayer.scaleMode = VideoScaleMode.MAINTAIN_ASPECT_RATIO;			//videoPlayer.activeVideoPlayerIndex = 1;			//videoPlayer.visibleVideoPlayerIndex = 1			videoPlayer.autoRewind = true;						// component controls			if (videoControls.volume_btn != null)				videoPlayer.muteButton = videoControls.volume_btn;			if (videoControls.fullscreen_btn != null)				//videoPlayer.fullScreenButton = videoControls.fullscreen_btn;			if (bufferingBar != null){				//videoPlayer.bufferingBar = bufferingBar;				bufferingBar.visible = false;			}			//if (videoControls.playpause_btn != null)				//videoPlayer.playPauseButton	= videoControls.playpause_btn;			if (paused_mc != null){				paused_mc.visible = false				paused_mc.mouseChildren = false				paused_mc.mouseEnabled = false			}									videoPlayer.fullScreenTakeOver = false;			video_holder.addChild(videoPlayer);						cuePointArray = new Array();						// default size will be size of the holder			videoPlayer.setSize(video_holder.width, video_holder.height)					}				private function addListeners():void 		{			videoPlayer.addEventListener(VideoEvent.PLAYHEAD_UPDATE, handleVideoUpdate, false, 0, true);			videoPlayer.addEventListener(VideoEvent.COMPLETE, videoDone,false,0,true);			videoPlayer.addEventListener(VideoEvent.SEEKED, videoSeeked,false,0,true);			videoPlayer.addEventListener(VideoEvent.READY, videoReady,false,0,true);			videoPlayer.addEventListener(VideoProgressEvent.PROGRESS, videoProgress,false,0,true);			videoPlayer.addEventListener(MetadataEvent.CUE_POINT, handleCuePoint,false,0,true);			videoPlayer.addEventListener(MetadataEvent.METADATA_RECEIVED, handleMetaData,false,0,true);			videoPlayer.addEventListener(VideoEvent.STATE_CHANGE, handleVideoState,false,0,true);									video_holder.addEventListener(MouseEvent.CLICK, handleVideoClick,false,0,true);				this.addEventListener(MouseEvent.ROLL_OVER, handleMouseOver,false,0,true);				this.addEventListener(MouseEvent.ROLL_OUT, handleMouseOut,false,0,true);							if (videoControls != null){				if (videoControls.caption_button != null){					videoControls.caption_button.addEventListener(MouseEvent.CLICK, handleCaptionButtonClick, false, 0, true);				}								videoControls.addEventListener(VideoControlsEvent.PLAY, handleVideoControl, false, 0, true);				videoControls.addEventListener(VideoControlsEvent.PAUSE, handleVideoControl, false, 0, true);								if (videoControls.hasSeekBar){					videoControls.addEventListener(VideoControlsEvent.SCRUB_STARTED, handleSeekDown, false, 0, true);					videoControls.addEventListener(VideoControlsEvent.SCRUB_STOPPED, handleSeekUp, false, 0, true);					videoControls.addEventListener(VideoControlsEvent.SCRUB_UPDATE, handleScrub, false, 0, true);				}			}		}				//_______________________________________________________________________________________________________________________INPUT						public function scaleVideo(adjust:Boolean):void 		{			if (videoPlayer == null) return;			if (adjust){				videoPlayer.scaleMode = VideoScaleMode.MAINTAIN_ASPECT_RATIO;					} else {				videoPlayer.scaleMode = VideoScaleMode.	NO_SCALE;			}		}						public function getVideoComponent():FLVPlaybackDispose		{			return videoPlayer;		}						private var captionConfigured:Boolean = false;		private var videoCaptionSource:String = ""		private var captionTextField:TextField		public function captionSource(val:String, captionBox_txt:TextField = null):void 		{			//killCaptionComponent() // deletes caption component if exists			captionConfigured = false			videoCaptionSource = val			captionTextField = captionBox_txt			TextHelper.formatHTML(captionTextField)			captionTextField.text = "";		}								public function setStaticImage(val:String):void 		{			clearStaticImage();			staticImage = new PhotoViewer(val)			staticImage.setSize(w, h)			video_holder.addChild(staticImage)			if(bufferingBar != null)				video_holder.addChild(bufferingBar);		}				private function clearStaticImage():void 		{			// remove old			if (staticImage != null){				with (video_holder){					if (contains(staticImage)) removeChild(staticImage);				}				staticImage.destroy();																										}		}				public function set autoHide(val:Boolean):void 		{			if (videoControls == null) return;			videoControls.autoHide = val		}				public function get autoHide():Boolean 		{			if (videoControls == null) return false;			return videoControls.autoHide;		}				public function set autoPlay(val:Boolean):void 		{			autoplay = val;		}				//public var ignoreSameSource	:Boolean = true; // wont try to load the same video twice in a row				private var videoToLoad:String		private var videoProcessed:Boolean = false		private var videoStreamClosed:Boolean = true		// saves video path so when playa button is clicked will load		// loads static images		public function loadVideo(flv:String, _static:String = null):void 		{			if (videoPlayer == null) return;						TweenMax.killDelayedCallsTo(simulateReady)						if (videoPlayerCaption != null)			 	videoPlayerCaption.showCaptions = false						// load static image, if any			if (_static != null) setStaticImage(_static)						videoToLoad = browserURL + flv;						if (videoControls.hasSeekBar){				videoControls.seekbar_mc.setValue(0);			}						if (videoControls.hasOwnProperty("setTime"))				videoControls.setTime(0, 0)						// ---------------			// if same video as last request			if (lastVideoFLV == flv){				// reset cue points				//if (staticImage != null) staticImage.visible = true				while(cuePointArray.length > 0){					trace("removing cue point")					videoPlayer.removeASCuePoint(cuePointArray.shift().time);				}				if (autoplay){					playWanted = true;					videoPlayer.seek(0)				} else {					stopVideo()				}								//  basically we are trying to mimic the full behavior of the video loading from scratch				TweenMax.delayedCall(.5, simulateReady);			} 			// if new video request			else {				stopVideo()									videoProcessed = false								videoControls.disable()								if (autoplay)					processVideo(videoToLoad)			}						// ---------------						lastVideoFLV = flv;						if (paused_mc != null){				paused_mc.visible = false			}						enableProgress = false // disable progress updating (stop laggy events)			videoControls.reset();		}				private function simulateReady():void 		{			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.READY));		}				// loads video from server and plays when enough is buffered		private function processVideo(flv:String):void 		{			videoStreamClosed = false;			videoProcessed = true;			trace("[VideoPlayer] loading: '" + flv + "'");			videoPlayer.source =  flv;						//setup queuepoints			for (var i:int = 0; i< cuePointArray.length; i++){				videoPlayer.addASCuePoint(cuePointArray[i].time,cuePointArray[i].name);			}						if (playOnLoad){				playWanted = true;				videoPlayer.playWhenEnoughDownloaded();			}						if (videoCaptionSource != "")				setupCaptioning();							enableProgress = true;		}				private function setupCaptioning():void 		{			// only create new if old one is null			if (videoPlayerCaption == null){				videoPlayerCaption = new FLVPlaybackCaptioning()				addChild(videoPlayerCaption)				//try{				videoPlayerCaption.autoLayout = true;				if (captionTextField != null){					captionTextField.text = ""					videoPlayerCaption.captionTarget = captionTextField;					captionTextField.mouseEnabled = false;				}				//videoPlayerCaption.addEventListener (CaptionChangeEvent.CAPTION_CHANGE, onCaptionChange, false, 0, true);				videoPlayerCaption.mouseEnabled = false;				videoPlayerCaption.mouseChildren = false;				videoPlayerCaption.simpleFormatting = true				videoPlayerCaption.videoPlayerIndex = 1				videoPlayerCaption.flvPlayback = videoPlayer;								//if (videoControls.caption_button != null)				videoPlayerCaption.captionButton = videoControls.caption_button							}									if (!showCaptions){				videoPlayerCaption.showCaptions = false			} else {				videoPlayerCaption.showCaptions = false				videoPlayerCaption.showCaptions = true			}						// assign the caption xml			videoPlayerCaption.source = videoCaptionSource;			captionConfigured = true					}				public function addCuePoint(_time, _name:String):void 		{			cuePointArray.push({time:_time, name:_name})			//videoPlayer.addASCuePoint(_time, _name)		}						private var playWanted:Boolean = false;		public function playVideo():void 		{			if (videoPlayer == null) return;			playWanted = true			trace("[VideoPlayer] play");			if (videoProcessed){				try{					videoPlayer.play();				} catch (e:Error){}			} else {				processVideo(videoToLoad)			}		}				public function pauseVideo():void 		{			playWanted = false;			if (videoPlayer == null) return;			try{				videoPlayer.pause();			} catch (err){}					}				public function stopVideo():void 		{			playWanted = false;			if (videoPlayer == null) return;			if (!videoProcessed) return						try{				videoPlayer.stop();			} catch (err){}					}				// scrub to time 		public function scrubTo(val:Number):void 		{			if (videoPlayer == null) return;			videoPlayer.seek(val);		}				public function setSize(_w, _h):void 		{			w = _w;			h = _h;			if (videoPlayer == null) return;			videoPlayer.setSize(w, h);			if (staticImage != null) staticImage.setSize(w, h)						if (bufferingBar != null){				bufferingBar.x = (_w / 2) + videoPlayer.x				bufferingBar.y = (_h / 2) + videoPlayer.y			}		}				private var usingControls:Boolean = true;		public function useControls(val:Boolean):void 		{			usingControls = val;			if (!val){				videoControls.visible = false;			} else {				videoControls.visible = true;			}								}						private function showControls():void 		{			if (!usingControls) return;			trace(this + " show controls")			if (videoControls.autoHide){				trace(this + " showing controls")				//TweenLite.to(videoControls, .5, {y:videoControlY});				TweenLite.to(videoControls, .5, {overwrite:1, autoAlpha:1});			}		}				private function hideControls():void 		{			trace(this + " hide controls")			if (videoControls.autoHide){				if (!mouseIsOver && videoPlayer.state == VideoState.PLAYING){					trace(this + " hiding controls")					//TweenLite.to(videoControls, .5, {y:videoControlY + videoControls.height});					TweenLite.to(videoControls, .5, {overwrite:1, autoAlpha:0});				}			}		}				public function moveControlsTo(spr:Sprite):void 		{			videoControls.y = 0;			videoControls.x = 0;			spr.addChild(videoControls);		}						//_______________________________________________________________________________________________________________________HANDLERS						private function handleCaptionButtonClick(e:MouseEvent):void 		{			if (videoPlayerCaption == null){				// videoplayercaption not installed yet				showCaptions = videoControls.captionToggle()			}  else {							showCaptions = videoPlayerCaption.showCaptions			}									var so:SharedObject = SharedObject.getLocal("vplayer_caption");			//trace("Current SharedObject size is " + so.size + " bytes.");			so.data.captionEnabled = showCaptions			so.flush();					}				//private function onCaptionChange(e:CaptionChangeEvent):void 		//{			//Debug.alert("test")					//}				private function handleMouseOver(e:MouseEvent):void 		{			mouseIsOver = true;			showControls();		}				private function handleMouseOut(e:MouseEvent):void 		{			mouseIsOver = false;			hideControls();		}				private function handleVideoClick(e:MouseEvent):void 		{			if (videoPlayer.playing){				pauseVideo()			} else if (videoPlayer.paused || videoPlayer.stopped){				playVideo()			}		}						// changes in video state		private function handleVideoState(e:VideoEvent):void 		{			//Debug.alert("VIDEO STATE: " + e.state)			switch(e.state) {								case VideoState.PLAYING:					hideBufferingBar();					dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.PLAY));					videoControls.showPlayButton(false)					if (staticImage != null)						TweenMax.to(staticImage, 1, {autoAlpha:0});											hideControls();					if (paused_mc != null){						paused_mc.visible = false					}					break;				case VideoState.PAUSED:					videoControls.showPlayButton(true)					showControls();					if (paused_mc != null){						paused_mc.visible = true					}					if (playWanted){						showBufferingBar()						videoPlayer.playWhenEnoughDownloaded();					} else {						hideBufferingBar()					}					break;				case VideoState.STOPPED:					if (playWanted){						showBufferingBar()					} else {						hideBufferingBar()					}					videoControls.showPlayButton(true)					showControls();					if (staticImage != null)						TweenMax.to(staticImage, 1, {autoAlpha:1});					break;									case VideoState.BUFFERING:					if (playWanted){						hideBufferingBar();					} else {						showBufferingBar();					}					break;								}		}				private function showBufferingBar():void		{			if (bufferingBar == null) return						TweenMax.delayedCall(1, bufferVis)					}				private function bufferVis():void		{			bufferingBar.visible = true;		}						private function hideBufferingBar():void		{			if (bufferingBar != null) {				TweenMax.killDelayedCallsTo(bufferVis);				bufferingBar.visible = false;			}		}				private function videoDone(e:VideoEvent):void 		{			trace("[VideoPlayer] video done")			playWanted = false;			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.DONE));		}				private function handleReady(e:VideoEvent):void 		{			trace("[VideoPlayer] video ready")			//if (videoPlayerCaption != null)										}				private var enableProgress:Boolean = true		private function videoProgress(e:VideoProgressEvent):void 		{						//if (!enableProgress) return;						var percent:Number = e.bytesLoaded / e.bytesTotal;			videoControls.seekbar_mc.setProgress(percent);		}						private function handleVideoUpdate(e:VideoEvent):void 		{			// update progress bar						if (videoControls.hasSeekBar){				var percent:Number = (e.playheadTime  / videoPlayer.totalTime);				videoControls.seekbar_mc.setValue(percent);			}						// update clock			//videoControls.time_txt.text = ConvertTime.secondsToMMSS(e.playheadTime) + "/" + ConvertTime.secondsToMMSS(videoPlayer.totalTime);			if (videoControls.hasOwnProperty("setTime"))				videoControls.setTime(e.playheadTime, videoPlayer.totalTime)						dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.UPDATE, {state:e.state, time:e.playheadTime}));		}				private function handleMetaData(e:MetadataEvent):void 		{			trace("---->" + e.info.keyframes);		}				private function videoSeeked(e:VideoEvent):void 		{			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.SEEK, {state:e.state, time:e.playheadTime}));		}				private function videoReady(e:VideoEvent):void 		{			videoControls.enable()			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.READY));		}				private function handleCuePoint(e:MetadataEvent):void 		{			dispatchEvent(new VideoPlayerEvent(VideoPlayerEvent.CUE_POINT, {name:e.info.name}));		}				private function handleScrub(e:VideoControlsEvent ):void 		{			videoPlayer.seekPercent(e.parameters.value * 100)		}				private function handleSeekDown(e:VideoControlsEvent):void 		{			if (videoPlayer.state == VideoState.PLAYING){				pre_seek_playing = true				pauseVideo()			} else {				pre_seek_playing = false;			}		}								private function handleSeekUp(e:VideoControlsEvent):void 		{			TweenMax.killDelayedCallsTo(playVideo)			if (pre_seek_playing){				TweenMax.delayedCall(.5, playVideo)			}		}						private function handleVideoControl(e:VideoControlsEvent):void 		{			switch (e.type){				case VideoControlsEvent.PLAY:					playVideo()					break;				case VideoControlsEvent.PAUSE:					trace("pause video");					pauseVideo()					break;			}		}				/*public override function get height():Number		{			return videoPlayer.height			}				public override function get width():Number		{			return videoPlayer.width;		}		*/						public override function destroy():void 		{			//closeStream();			videoPlayer.getVideoPlayer(videoPlayer.activeVideoPlayerIndex).close();						TweenMax.killDelayedCallsTo(simulateReady)			TweenMax.killDelayedCallsTo(playVideo);			TweenMax.killDelayedCallsTo(bufferVis);						if (staticImage != null)				TweenMax.killTweensOf(staticImage);						videoPlayer.soundTransform = null			//videoPlayer.source = null;						videoPlayer.removeEventListener(VideoEvent.PLAYHEAD_UPDATE, handleVideoUpdate);			videoPlayer.removeEventListener(VideoEvent.COMPLETE, videoDone);			videoPlayer.removeEventListener(VideoEvent.SEEKED, videoSeeked);			videoPlayer.removeEventListener(VideoEvent.READY, videoReady);			videoPlayer.removeEventListener(VideoProgressEvent.PROGRESS, videoProgress);			videoPlayer.removeEventListener(MetadataEvent.CUE_POINT, handleCuePoint);			videoPlayer.removeEventListener(MetadataEvent.METADATA_RECEIVED, handleMetaData);			//videoPlayer.removeEventListener(VideoEvent.READY, handleReady);			videoPlayer.removeEventListener(VideoEvent.STATE_CHANGE, handleVideoState);						video_holder.removeEventListener(MouseEvent.CLICK, handleVideoClick);				this.removeEventListener(MouseEvent.ROLL_OVER, handleMouseOver);				this.removeEventListener(MouseEvent.ROLL_OUT, handleMouseOut);							if (videoControls != null){				if (videoControls.caption_button != null)					videoControls.caption_button.removeEventListener(MouseEvent.CLICK, handleCaptionButtonClick)				videoControls.removeEventListener(VideoControlsEvent.PLAY, handleVideoControl)				videoControls.removeEventListener(VideoControlsEvent.PAUSE, handleVideoControl)								if (videoControls.hasSeekBar){					videoControls.removeEventListener(VideoControlsEvent.SCRUB_STARTED, handleSeekDown)					videoControls.removeEventListener(VideoControlsEvent.SCRUB_STOPPED, handleSeekUp)					videoControls.removeEventListener(VideoControlsEvent.SCRUB_UPDATE, handleScrub);				}												videoControls.destroy();			}								cuePointArray = null						killCaptionComponent()						if (staticImage != null){				staticImage.destroy()			}									// this method supposedly fixes memory leaks, I question if there really are any in new versions of components			FLVPlaybackDispose(videoPlayer).dispose();									video_holder.removeChild(videoPlayer)				videoPlayer = null					}				private function closeStream():void 		{			//try{				videoPlayer.closeVideoPlayer(1)			//} catch(e:Error){}					}				public override function set soundTransform(value:SoundTransform):void		{			videoPlayer.soundTransform = value;		}				private function killCaptionComponent():void 		{			if (videoPlayerCaption != null){							//videoPlayerCaption.removeEventListener(CaptionChangeEvent.CAPTION_CHANGE, onCaptionChange); 				removeChild(videoPlayerCaption)				captionTextField = null;				videoPlayerCaption.source = null;				videoPlayerCaption = null;			}		}					}}