package pdh.text{	/**			Based on font loader to apply styles to text fields.  Once fonts are loaded and associated with names, you can refer		to static methods in order to apply a font to a textfield				Example usage:				// load an external font file and identify fonts to manage in it:		var fontstyler:TextStyer = new TextStyer("fonts.swf", ["arial", "new times roman"])				//Set a textfield to the arial font:		TextStyer.styleTextField(my_textfield, "arial");				//Do the same as above but for html <p> tags		TextStyer.styleTextField(my_textfield, "arial", true);				//Apply a style to a custom css class		TextStyer.styleTextField(my_textfield, "arial", true, "customclass");		*/	import flash.text.Font;	import flash.utils.Dictionary;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.text.StyleSheet;	import flash.events.Event;	import pdh.events.FontLoaderEvent;	import pdh.text.FontLoader;	public class TextStyler extends FontLoader	{		protected static var fontDict		:Dictionary;		protected static var fontsLoaded	:Boolean = false;				private static var format			:TextFormat = new TextFormat();			function TextStyler(file:String, fontarray:Array):void		{			init(file, fontarray ); // list of registered fonts go here		}				// prepares a textfield to accept embedded fonts.  Will use defaultTextFormat for non HTML and styleSheet for HTML		public static function styleTextField(_field:TextField, _fontname:String, _html:Boolean = false, id:String = "font"):TextFormat		{						var fontN:String;						if (fontsLoaded){				fontN = fontDict[_fontname];				_field.embedFonts = true;			} else {				fontN = "_sans";				_field.embedFonts = false;			}									// apply css for HTML text			if (_html){				var cssObj:Object = {fontFamily:fontN};				var css:StyleSheet;				if (_field.styleSheet == null){					css = new StyleSheet();				} else {					css = _field.styleSheet;				}				css.setStyle("." + id,cssObj);				_field.styleSheet = css;			} 			// apply textformat			else {				format.font = fontN;				_field.defaultTextFormat = format;				_field.text = _field.text;				}						return format;		}								public static function getFont(id:String):String		{			if (!fontsLoaded){				return "_sans";			} else {				return fontDict[id];			}		}				protected override function fontLoaded(e:Event):void		{			super.fontLoaded(e);			associateFontWithClass();			dispatchEvent(new FontLoaderEvent(FontLoaderEvent.LOADED));		} 				// associates a font name with the loaded class		private function associateFontWithClass():void 		{			fontDict = new Dictionary();						var f_arr:Array = Font.enumerateFonts(false);			trace("font------->" + f_arr);						for (var i:int = 0; i < fontArray.length; i++) {				for (var i2:int = 0; i2 < f_arr.length ; i2++){					//trace(  f_arr[i2].fontN + " -- " +  _fontsDomain.getDefinition(fontArray[i]) )					if (getName(f_arr[i2]) ==  getName( _fontsDomain.getDefinition(fontArray[i]).toString())  ){						fontDict[fontArray[i]] = f_arr[i2].fontName;						fontsLoaded = true;						trace("REGISTER FONT = " + fontArray[i] + " with " + fontDict[fontArray[i]]);					}				}			}		}						public static function convertItalicTags($str:String, id:String):String 		{ 			var $search:String =  "<i>";			var $replace:String = "<span class='"+id+"'>";			var str2:String = $str.split($search).join($replace); 						var $search2:String =  "</i>";			var $replace2:String = "</span>";			return str2.split($search2).join($replace2); 		}				public static function convertBoldTags($str:String, id:String):String 		{ 			var $search:String =  "<b>";			var $replace:String = "<span class='"+id+"'>";			var str2:String = $str.split($search).join($replace); 						var $search2:String =  "</b>";			var $replace2:String = "</span>";			return str2.split($search2).join($replace2); 		}											} // end class} // end package